// C++ bridge implementation for VF3 algorithm bindings.
// Single translation unit prevents duplicate symbols from header-only templates.

// Windows defines _WIN32, not WIN32. Define WIN32 for vf3lib compatibility.
#ifdef _WIN32
#ifndef WIN32
#define WIN32
#endif
#endif

#include <cstdint>
#include <fstream>
#include <map>
#include <memory>
#include <string>
#include <vector>

// Suppress warnings from vendored vf3lib headers.
#if defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcpp"
#pragma GCC diagnostic ignored "-Wdelete-non-virtual-dtor"
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#pragma GCC diagnostic ignored "-Wreorder"
#pragma GCC diagnostic ignored "-Wsign-compare"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wunused-variable"
#endif

#include "ARGraph.hpp"
#include "FastCheck.hpp"
#include "MatchingEngine.hpp"
#include "NodeClassifier.hpp"
#include "NodeSorter.hpp"
#include "ProbabilityStrategy.hpp"
#include "RINodeSorter.hpp"
#include "VF3LightSubState.hpp"
#include "VF3NodeSorter.hpp"
#include "VF3SubState.hpp"
#include "loaders/ARGLoader.hpp"
#include "loaders/EdgeStreamARGLoader.hpp"
#include "loaders/FastStreamARGLoader.hpp"

// Parallel algorithm is Linux-only due to cpu_set_t and pthread_setaffinity_np
#ifdef __linux__
#include "parallel/CloneableVF3ParallelSubState.hpp"
#include "parallel/ParallelMatchingEngine.hpp"
#include "parallel/ParallelMatchingEngineWLS.hpp"
#endif

#include "vf3lib-rs/src/lib.rs.h"  // Generated by CXX.

// Include platform-specific time headers
#ifdef _WIN32
#include "WindowsTime.h"
#else
#include <sys/time.h>
#endif

namespace vf3ffi {

// Default data type from VFLib.h (int32_t when VF3BIO is undefined).
typedef std::int32_t data_t;

using SeqState = vflib::VF3SubState<data_t, data_t, vflib::Empty, vflib::Empty>;
using LightState = vflib::VF3LightSubState<data_t, data_t, vflib::Empty, vflib::Empty>;
#ifdef __linux__
using ParState = vflib::CloneableVF3ParallelSubState<data_t, data_t, vflib::Empty, vflib::Empty>;
#endif

// Convert Rust string slice to std::string.
static inline std::string to_string_view(rust::Str s) {
    return std::string(s.data(), s.size());
}

// Calculate elapsed seconds between two timevals.
static inline double elapsed_secs(const timeval &a, const timeval &b) {
    return (b.tv_sec - a.tv_sec) + (b.tv_usec - a.tv_usec) / 1e6;
}

// Create graph loader based on format string.
static std::unique_ptr<vflib::ARGLoader<data_t, vflib::Empty>>
create_loader(std::istream &in, const std::string &fmt, bool undirected) {
    if (fmt == "vf") {
        return std::unique_ptr<vflib::ARGLoader<data_t, vflib::Empty>>(
            new vflib::FastStreamARGLoader<data_t, vflib::Empty>(in, undirected));
    }

    if (fmt == "edge") {
        return std::unique_ptr<vflib::ARGLoader<data_t, vflib::Empty>>(
            new vflib::EdgeStreamARGLoader<data_t, vflib::Empty>(in, undirected));
    }

    return nullptr;
}

template <typename StateT>
static VF3Result run_seq(
    const std::string &patt_path,
    const std::string &targ_path,
    const std::string &fmt,
    bool undirected,
    bool store_solutions,
    bool first_only,
    bool verbose,
    float repetition_time_limit,
    bool edge_induced) {
    VF3Result out{1, 0, 0.0, 0.0};
    std::ifstream graphInPat(patt_path.c_str(), std::ios::in | std::ios::binary);
    std::ifstream graphInTarg(targ_path.c_str(), std::ios::in | std::ios::binary);

    if (!graphInPat.good() || !graphInTarg.good())
        return out;

    auto pattloader = create_loader(graphInPat, fmt, undirected);
    auto targloader = create_loader(graphInTarg, fmt, undirected);

    if (!pattloader || !targloader)
        return out;

    vflib::ARGraph<data_t, vflib::Empty> patt_graph(pattloader.get());
    vflib::ARGraph<data_t, vflib::Empty> targ_graph(targloader.get());
    vflib::MatchingEngine<StateT> *me =
        new vflib::MatchingEngine<StateT>(store_solutions, edge_induced);

    if (!me) {
        return out;
    }

    struct timeval start, fastcheck, iter, end;
    double timeFirst = 0.0, timeAll = 0.0, totalExecTime = 0.0;
    int rep = 0;

    vflib::FastCheck<data_t, data_t, vflib::Empty, vflib::Empty> check(&patt_graph, &targ_graph);
    std::vector<uint32_t> class_patt, class_targ;
    uint32_t classes_count = 0;

    gettimeofday(&start, NULL);

    if (check.CheckSubgraphIsomorphism()) {
        if (verbose) {
            gettimeofday(&fastcheck, NULL);
            (void)fastcheck;
        }

        vflib::NodeClassifier<data_t, vflib::Empty> classifier(&targ_graph);
        vflib::NodeClassifier<data_t, vflib::Empty> classifier_patt(&patt_graph, classifier);
        class_patt = classifier_patt.GetClasses();
        class_targ = classifier.GetClasses();
        classes_count = classifier.CountClasses();
    }

    do {
        rep++;
        me->ResetSolutionCounter();
        gettimeofday(&iter, NULL);

        if (check.CheckSubgraphIsomorphism()) {
            vflib::VF3NodeSorter<
                data_t, vflib::Empty, vflib::SubIsoNodeProbability<data_t, vflib::Empty>>
                sorter(&targ_graph);
            std::vector<vflib::nodeID_t> sorted = sorter.SortNodes(&patt_graph);
            StateT s0(
                &patt_graph, &targ_graph, class_patt.data(), class_targ.data(), classes_count,
                sorted.data(), edge_induced);

            if (first_only) {
                me->FindFirstMatching(s0);
            } else {
                me->FindAllMatchings(s0);
            }
        }

        gettimeofday(&end, NULL);
        timeAll = elapsed_secs(iter, end);
        totalExecTime += timeAll;

        if (!first_only) {
            end = me->GetFirstSolutionTime();
            timeFirst += elapsed_secs(iter, end);
        }
    } while (totalExecTime < repetition_time_limit);

    timeAll = totalExecTime / rep;

    if (!first_only) {
        timeFirst /= rep;
    } else {
        timeFirst = timeAll;
    }

    out.status = 0;
    out.solutions = me->GetSolutionsCount();
    out.time_first = timeFirst;
    out.time_all = timeAll;
    delete me;
    return out;
}

VF3Result run_vf3(
    rust::Str pattern,
    rust::Str target,
    rust::Str format,
    bool undirected,
    bool store_solutions,
    bool first_only,
    bool verbose,
    float repetition_time_limit,
    bool edge_induced) {
    return run_seq<SeqState>(
        to_string_view(pattern), to_string_view(target), to_string_view(format), undirected,
        store_solutions, first_only, verbose, repetition_time_limit, edge_induced);
}

VF3Result run_vf3l(
    rust::Str pattern,
    rust::Str target,
    rust::Str format,
    bool undirected,
    bool store_solutions,
    bool first_only,
    bool verbose,
    float repetition_time_limit,
    bool edge_induced) {
    return run_seq<LightState>(
        to_string_view(pattern), to_string_view(target), to_string_view(format), undirected,
        store_solutions, first_only, verbose, repetition_time_limit, edge_induced);
}

#ifdef __linux__
VF3Result run_vf3p(
    rust::Str pattern,
    rust::Str target,
    rust::Str format,
    bool undirected,
    bool store_solutions,
    bool verbose,
    float repetition_time_limit,
    bool edge_induced,
    std::int8_t algo,
    std::int16_t cpu,
    std::int16_t num_threads,
    bool lock_free,
    std::int16_t ssr_high_limit,
    std::int16_t ssr_local_stack_limit) {
    (void)verbose;  // Unused in parallel implementation.
    VF3Result out{1, 0, 0.0, 0.0};
    std::ifstream graphInPat(to_string_view(pattern).c_str(), std::ios::in | std::ios::binary);
    std::ifstream graphInTarg(to_string_view(target).c_str(), std::ios::in | std::ios::binary);

    if (!graphInPat.good() || !graphInTarg.good())
        return out;

    std::string fmt = to_string_view(format);

    auto pattloader = create_loader(graphInPat, fmt, undirected);
    auto targloader = create_loader(graphInTarg, fmt, undirected);

    if (!pattloader || !targloader)
        return out;

    vflib::ARGraph<data_t, vflib::Empty> patt_graph(pattloader.get());
    vflib::ARGraph<data_t, vflib::Empty> targ_graph(targloader.get());

    vflib::MatchingEngine<ParState> *me = nullptr;

    if (algo == 1) {
        me = new vflib::ParallelMatchingEngine<ParState>(
            num_threads, store_solutions, lock_free, cpu);
    } else if (algo == 2) {
        me = new vflib::ParallelMatchingEngineWLS<ParState>(
            num_threads, store_solutions, lock_free, cpu, ssr_high_limit, ssr_local_stack_limit);
    } else {
        return out;
    }

    struct timeval iter, end;
    double timeAll = 0.0, totalExecTime = 0.0;
    int rep = 0;

    vflib::FastCheck<data_t, data_t, vflib::Empty, vflib::Empty> check(&patt_graph, &targ_graph);
    std::vector<uint32_t> class_patt, class_targ;
    uint32_t classes_count = 0;

    if (check.CheckSubgraphIsomorphism()) {
        vflib::NodeClassifier<data_t, vflib::Empty> classifier(&targ_graph);
        vflib::NodeClassifier<data_t, vflib::Empty> classifier_patt(&patt_graph, classifier);
        class_patt = classifier_patt.GetClasses();
        class_targ = classifier.GetClasses();
        classes_count = classifier.CountClasses();
    }

    do {
        rep++;
        me->ResetSolutionCounter();
        gettimeofday(&iter, NULL);

        if (check.CheckSubgraphIsomorphism()) {
            vflib::VF3NodeSorter<
                data_t, vflib::Empty, vflib::SubIsoNodeProbability<data_t, vflib::Empty>>
                sorter(&targ_graph);
            std::vector<vflib::nodeID_t> sorted = sorter.SortNodes(&patt_graph);
            ParState s0(
                &patt_graph, &targ_graph, class_patt.data(), class_targ.data(), classes_count,
                sorted.data(), edge_induced);
            me->FindAllMatchings(s0);
        }

        gettimeofday(&end, NULL);
        timeAll = elapsed_secs(iter, end);
        totalExecTime += timeAll;
    } while (totalExecTime < repetition_time_limit);

    double timeFirst = timeAll;
    timeAll = totalExecTime / rep;
    VF3Result res{0, me->GetSolutionsCount(), timeFirst, timeAll};
    delete me;
    return res;
}
#else
// Stub implementation for non-Linux platforms
VF3Result run_vf3p(
    rust::Str pattern,
    rust::Str target,
    rust::Str format,
    bool undirected,
    bool store_solutions,
    bool verbose,
    float repetition_time_limit,
    bool edge_induced,
    std::int8_t algo,
    std::int16_t cpu,
    std::int16_t num_threads,
    bool lock_free,
    std::int16_t ssr_high_limit,
    std::int16_t ssr_local_stack_limit) {
    // Parallel VF3 is not supported on this platform due to Linux-specific thread affinity APIs
    (void)pattern;
    (void)target;
    (void)format;
    (void)undirected;
    (void)store_solutions;
    (void)verbose;
    (void)repetition_time_limit;
    (void)edge_induced;
    (void)algo;
    (void)cpu;
    (void)num_threads;
    (void)lock_free;
    (void)ssr_high_limit;
    (void)ssr_local_stack_limit;
    return VF3Result{2, 0, 0.0, 0.0};  // Return error code 2 for unsupported platform
}
#endif

}  // namespace vf3ffi
