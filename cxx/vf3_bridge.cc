// C++ bridge implementation for VF3 algorithm bindings.
// Single translation unit prevents duplicate symbols from header-only templates.

// Windows defines _WIN32, not WIN32. Define WIN32 for vf3lib compatibility.
#ifdef _WIN32
#ifndef WIN32
#define WIN32
#endif
#endif

#include <algorithm>
#include <cassert>
#include <cctype>
#include <cstdint>
#include <fstream>
#include <limits>
#include <map>
#include <memory>
#include <sstream>
#include <string>
#include <unordered_map>
#include <vector>

// Suppress warnings from vendored vf3lib headers.
#if defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcpp"
#pragma GCC diagnostic ignored "-Wdelete-non-virtual-dtor"
#pragma GCC diagnostic ignored "-Wdeprecated"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#pragma GCC diagnostic ignored "-Wreorder"
#pragma GCC diagnostic ignored "-Wsign-compare"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wunused-variable"
#endif

#include "ARGraph.hpp"
#include "FastCheck.hpp"
#include "MatchingEngine.hpp"
#include "NodeClassifier.hpp"
#include "NodeSorter.hpp"
#include "ProbabilityStrategy.hpp"
#include "RINodeSorter.hpp"
#include "VF3LightSubState.hpp"
#include "VF3NodeSorter.hpp"
#include "VF3SubState.hpp"
#include "loaders/ARGLoader.hpp"
#include "loaders/FastStreamARGLoader.hpp"

// Parallel algorithm is Linux-only due to cpu_set_t and pthread_setaffinity_np
#ifdef __linux__
#include "parallel/CloneableVF3ParallelSubState.hpp"
#include "parallel/ParallelMatchingEngine.hpp"
#include "parallel/ParallelMatchingEngineWLS.hpp"
#endif

#include "vf3lib-rs/src/lib.rs.h"  // Generated by CXX.

// Include platform-specific time headers
#ifdef _WIN32
#include "WindowsTime.h"
#else
#include <sys/time.h>
#endif

namespace vf3ffi {

// Default data type from VFLib.h (int32_t when VF3BIO is undefined).
typedef std::int32_t data_t;

using SeqState = vflib::VF3SubState<data_t, data_t, vflib::Empty, vflib::Empty>;
using LightState = vflib::VF3LightSubState<data_t, data_t, vflib::Empty, vflib::Empty>;
#ifdef __linux__
using ParState = vflib::CloneableVF3ParallelSubState<data_t, data_t, vflib::Empty, vflib::Empty>;
#endif

class PortableEdgeListLoader final : public vflib::ARGLoader<data_t, vflib::Empty> {
  public:
    PortableEdgeListLoader(std::istream &in, bool undirected) : undirected_(undirected) {
        parse(in);
    }

    bool is_valid() const {
        return valid_;
    }

    uint32_t NodeCount() const override {
        return node_count_;
    }

    data_t GetNodeAttr(vflib::nodeID_t) override {
        return node_attribute_;
    }

    uint32_t OutEdgeCount(vflib::nodeID_t node) const override {
        if (node >= adjacency_.size()) {
            return 0;
        }
        return static_cast<uint32_t>(adjacency_[node].size());
    }

    vflib::nodeID_t GetOutEdge(vflib::nodeID_t node, uint32_t i, vflib::Empty *pattr) override {
        assert(node < adjacency_.size());
        assert(i < adjacency_[node].size());
        *pattr = edge_attribute_;
        return adjacency_[node][i];
    }

  private:
    static void trim(std::string &line) {
        size_t start = 0;
        while (start < line.size() && std::isspace(static_cast<unsigned char>(line[start]))) {
            ++start;
        }
        size_t end = line.size();
        while (end > start && std::isspace(static_cast<unsigned char>(line[end - 1]))) {
            --end;
        }
        if (start == 0 && end == line.size()) {
            return;
        }
        line = line.substr(start, end - start);
    }

    void parse(std::istream &in) {
        std::vector<std::pair<vflib::nodeID_t, vflib::nodeID_t>> edges;
        std::vector<vflib::nodeID_t> nodes;
        std::string line;

        while (std::getline(in, line)) {
            if (!line.empty() && line.back() == '\r') {
                line.pop_back();
            }
            trim(line);
            if (line.empty() || line[0] == '#') {
                continue;
            }

            std::istringstream iss(line);
            unsigned long long raw_u = 0;
            unsigned long long raw_v = 0;
            if (!(iss >> raw_u >> raw_v)) {
                valid_ = false;
                return;
            }

            const auto max_id =
                static_cast<unsigned long long>((std::numeric_limits<vflib::nodeID_t>::max)());
            if (raw_u == 0 || raw_v == 0 || raw_u > max_id || raw_v > max_id) {
                valid_ = false;
                return;
            }

            const auto u = static_cast<vflib::nodeID_t>(raw_u - 1);
            const auto v = static_cast<vflib::nodeID_t>(raw_v - 1);
            if (u == v) {
                valid_ = false;
                return;
            }

            edges.emplace_back(u, v);
            nodes.push_back(u);
            nodes.push_back(v);
        }

        if (nodes.empty()) {
            adjacency_.clear();
            node_count_ = 0;
            valid_ = true;
            return;
        }

        std::sort(nodes.begin(), nodes.end());
        nodes.erase(std::unique(nodes.begin(), nodes.end()), nodes.end());
        if (nodes.size() > static_cast<size_t>((std::numeric_limits<uint32_t>::max)())) {
            valid_ = false;
            return;
        }

        std::unordered_map<vflib::nodeID_t, vflib::nodeID_t> id_map;
        id_map.reserve(nodes.size());
        for (size_t idx = 0; idx < nodes.size(); ++idx) {
            id_map[nodes[idx]] = static_cast<vflib::nodeID_t>(idx);
        }

        adjacency_.assign(nodes.size(), {});
        for (const auto &edge : edges) {
            const auto it_u = id_map.find(edge.first);
            const auto it_v = id_map.find(edge.second);
            if (it_u == id_map.end() || it_v == id_map.end()) {
                valid_ = false;
                return;
            }
            adjacency_[it_u->second].push_back(it_v->second);
            if (undirected_) {
                adjacency_[it_v->second].push_back(it_u->second);
            }
        }

        for (auto &neighbors : adjacency_) {
            std::sort(neighbors.begin(), neighbors.end());
            neighbors.erase(std::unique(neighbors.begin(), neighbors.end()), neighbors.end());
        }

        node_count_ = static_cast<uint32_t>(adjacency_.size());
        valid_ = true;
    }

    bool undirected_;
    bool valid_ = false;
    uint32_t node_count_ = 0;
    data_t node_attribute_{};
    vflib::Empty edge_attribute_;
    std::vector<std::vector<vflib::nodeID_t>> adjacency_;
};

// Convert Rust string slice to std::string.
static inline std::string to_string_view(rust::Str s) {
    return std::string(s.data(), s.size());
}

// Calculate elapsed seconds between two timevals.
static inline double elapsed_secs(const timeval &a, const timeval &b) {
    return (b.tv_sec - a.tv_sec) + (b.tv_usec - a.tv_usec) / 1e6;
}

// Create graph loader based on format string.
static std::unique_ptr<vflib::ARGLoader<data_t, vflib::Empty>>
create_loader(std::istream &in, const std::string &fmt, bool undirected) {
    if (fmt == "vf") {
        return std::unique_ptr<vflib::ARGLoader<data_t, vflib::Empty>>(
            new vflib::FastStreamARGLoader<data_t, vflib::Empty>(in, undirected));
    }

    if (fmt == "edge") {
        auto loader = std::make_unique<PortableEdgeListLoader>(in, undirected);
        if (!loader->is_valid()) {
            return nullptr;
        }
        return loader;
    }

    return nullptr;
}

template <typename StateT>
static VF3Result run_seq(
    const std::string &patt_path,
    const std::string &targ_path,
    const std::string &fmt,
    bool undirected,
    bool store_solutions,
    bool first_only,
    bool verbose,
    float repetition_time_limit,
    bool edge_induced) {
    VF3Result out{1, 0, 0.0, 0.0};
    std::ifstream graphInPat(patt_path.c_str(), std::ios::in | std::ios::binary);
    std::ifstream graphInTarg(targ_path.c_str(), std::ios::in | std::ios::binary);

    if (!graphInPat.good() || !graphInTarg.good())
        return out;

    auto pattloader = create_loader(graphInPat, fmt, undirected);
    auto targloader = create_loader(graphInTarg, fmt, undirected);

    if (!pattloader || !targloader)
        return out;

    vflib::ARGraph<data_t, vflib::Empty> patt_graph(pattloader.get());
    vflib::ARGraph<data_t, vflib::Empty> targ_graph(targloader.get());
    vflib::MatchingEngine<StateT> *me =
        new vflib::MatchingEngine<StateT>(store_solutions, edge_induced);

    if (!me) {
        return out;
    }

    struct timeval start, fastcheck, iter, end;
    double timeFirst = 0.0, timeAll = 0.0, totalExecTime = 0.0;
    int rep = 0;

    vflib::FastCheck<data_t, data_t, vflib::Empty, vflib::Empty> check(&patt_graph, &targ_graph);
    std::vector<uint32_t> class_patt, class_targ;
    uint32_t classes_count = 0;

    gettimeofday(&start, NULL);

    if (check.CheckSubgraphIsomorphism()) {
        if (verbose) {
            gettimeofday(&fastcheck, NULL);
            (void)fastcheck;
        }

        vflib::NodeClassifier<data_t, vflib::Empty> classifier(&targ_graph);
        vflib::NodeClassifier<data_t, vflib::Empty> classifier_patt(&patt_graph, classifier);
        class_patt = classifier_patt.GetClasses();
        class_targ = classifier.GetClasses();
        classes_count = classifier.CountClasses();
    }

    do {
        rep++;
        me->ResetSolutionCounter();
        gettimeofday(&iter, NULL);

        if (check.CheckSubgraphIsomorphism()) {
            vflib::VF3NodeSorter<
                data_t, vflib::Empty, vflib::SubIsoNodeProbability<data_t, vflib::Empty>>
                sorter(&targ_graph);
            std::vector<vflib::nodeID_t> sorted = sorter.SortNodes(&patt_graph);
            StateT s0(
                &patt_graph, &targ_graph, class_patt.data(), class_targ.data(), classes_count,
                sorted.data(), edge_induced);

            if (first_only) {
                me->FindFirstMatching(s0);
            } else {
                me->FindAllMatchings(s0);
            }
        }

        gettimeofday(&end, NULL);
        timeAll = elapsed_secs(iter, end);
        totalExecTime += timeAll;

        if (!first_only) {
            end = me->GetFirstSolutionTime();
            timeFirst += elapsed_secs(iter, end);
        }
    } while (totalExecTime < repetition_time_limit);

    timeAll = totalExecTime / rep;

    if (!first_only) {
        timeFirst /= rep;
    } else {
        timeFirst = timeAll;
    }

    out.status = 0;
    out.solutions = me->GetSolutionsCount();
    out.time_first = timeFirst;
    out.time_all = timeAll;
    delete me;
    return out;
}

VF3Result run_vf3(
    rust::Str pattern,
    rust::Str target,
    rust::Str format,
    bool undirected,
    bool store_solutions,
    bool first_only,
    bool verbose,
    float repetition_time_limit,
    bool edge_induced) {
    return run_seq<SeqState>(
        to_string_view(pattern), to_string_view(target), to_string_view(format), undirected,
        store_solutions, first_only, verbose, repetition_time_limit, edge_induced);
}

VF3Result run_vf3l(
    rust::Str pattern,
    rust::Str target,
    rust::Str format,
    bool undirected,
    bool store_solutions,
    bool first_only,
    bool verbose,
    float repetition_time_limit,
    bool edge_induced) {
    return run_seq<LightState>(
        to_string_view(pattern), to_string_view(target), to_string_view(format), undirected,
        store_solutions, first_only, verbose, repetition_time_limit, edge_induced);
}

#ifdef __linux__
VF3Result run_vf3p(
    rust::Str pattern,
    rust::Str target,
    rust::Str format,
    bool undirected,
    bool store_solutions,
    bool verbose,
    float repetition_time_limit,
    bool edge_induced,
    std::int8_t algo,
    std::int16_t cpu,
    std::int16_t num_threads,
    bool lock_free,
    std::int16_t ssr_high_limit,
    std::int16_t ssr_local_stack_limit) {
    (void)verbose;  // Unused in parallel implementation.
    VF3Result out{1, 0, 0.0, 0.0};
    std::ifstream graphInPat(to_string_view(pattern).c_str(), std::ios::in | std::ios::binary);
    std::ifstream graphInTarg(to_string_view(target).c_str(), std::ios::in | std::ios::binary);

    if (!graphInPat.good() || !graphInTarg.good())
        return out;

    std::string fmt = to_string_view(format);

    auto pattloader = create_loader(graphInPat, fmt, undirected);
    auto targloader = create_loader(graphInTarg, fmt, undirected);

    if (!pattloader || !targloader)
        return out;

    vflib::ARGraph<data_t, vflib::Empty> patt_graph(pattloader.get());
    vflib::ARGraph<data_t, vflib::Empty> targ_graph(targloader.get());

    vflib::MatchingEngine<ParState> *me = nullptr;

    if (algo == 1) {
        me = new vflib::ParallelMatchingEngine<ParState>(
            num_threads, store_solutions, lock_free, cpu);
    } else if (algo == 2) {
        me = new vflib::ParallelMatchingEngineWLS<ParState>(
            num_threads, store_solutions, lock_free, cpu, ssr_high_limit, ssr_local_stack_limit);
    } else {
        return out;
    }

    struct timeval iter, end;
    double timeAll = 0.0, totalExecTime = 0.0;
    int rep = 0;

    vflib::FastCheck<data_t, data_t, vflib::Empty, vflib::Empty> check(&patt_graph, &targ_graph);
    std::vector<uint32_t> class_patt, class_targ;
    uint32_t classes_count = 0;

    if (check.CheckSubgraphIsomorphism()) {
        vflib::NodeClassifier<data_t, vflib::Empty> classifier(&targ_graph);
        vflib::NodeClassifier<data_t, vflib::Empty> classifier_patt(&patt_graph, classifier);
        class_patt = classifier_patt.GetClasses();
        class_targ = classifier.GetClasses();
        classes_count = classifier.CountClasses();
    }

    do {
        rep++;
        me->ResetSolutionCounter();
        gettimeofday(&iter, NULL);

        if (check.CheckSubgraphIsomorphism()) {
            vflib::VF3NodeSorter<
                data_t, vflib::Empty, vflib::SubIsoNodeProbability<data_t, vflib::Empty>>
                sorter(&targ_graph);
            std::vector<vflib::nodeID_t> sorted = sorter.SortNodes(&patt_graph);
            ParState s0(
                &patt_graph, &targ_graph, class_patt.data(), class_targ.data(), classes_count,
                sorted.data(), edge_induced);
            me->FindAllMatchings(s0);
        }

        gettimeofday(&end, NULL);
        timeAll = elapsed_secs(iter, end);
        totalExecTime += timeAll;
    } while (totalExecTime < repetition_time_limit);

    double timeFirst = timeAll;
    timeAll = totalExecTime / rep;
    VF3Result res{0, me->GetSolutionsCount(), timeFirst, timeAll};
    delete me;
    return res;
}
#else
// Stub implementation for non-Linux platforms
VF3Result run_vf3p(
    rust::Str pattern,
    rust::Str target,
    rust::Str format,
    bool undirected,
    bool store_solutions,
    bool verbose,
    float repetition_time_limit,
    bool edge_induced,
    std::int8_t algo,
    std::int16_t cpu,
    std::int16_t num_threads,
    bool lock_free,
    std::int16_t ssr_high_limit,
    std::int16_t ssr_local_stack_limit) {
    // Parallel VF3 is not supported on this platform due to Linux-specific thread affinity APIs
    (void)pattern;
    (void)target;
    (void)format;
    (void)undirected;
    (void)store_solutions;
    (void)verbose;
    (void)repetition_time_limit;
    (void)edge_induced;
    (void)algo;
    (void)cpu;
    (void)num_threads;
    (void)lock_free;
    (void)ssr_high_limit;
    (void)ssr_local_stack_limit;
    return VF3Result{2, 0, 0.0, 0.0};  // Return error code 2 for unsupported platform
}
#endif

}  // namespace vf3ffi
